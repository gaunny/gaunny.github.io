[{"title":"leetcode-时间复杂度问题","url":"/2020/01/17/leetcode-时间复杂度问题/","content":"# leetcode算法面试\n\n## 时间复杂度\n\n![](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117171132054.png)\n\n![image-20200117171258470](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117171258470.png)\n\nn=1000时，执行算法A与执行算法B速度相同，＞1000后，A比B速度快。当数据规模大时，算法时间复杂度的差距还是很大的。\n\n**大O表示的是时间的上界。**在业界，我们就用O来表示算法执行的最低上界，一般不会说归并排序算法是O(n^2)，而是O(nlogn)的。\n\nO(nlogn+n)=O(nlogn) \n\nO(nlogn+n^2)=O(n^2)\n\nO(AlogA+B) A和B没有关系\n\n对邻接表实现的图进行遍历：时间复杂度O(V+E) 顶点个数V 边个数E\n\n#### 一个时间复杂度的问题：\n\n有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？\n\n假设最长的字符串长度为s；数组中有n个字符串。对每个字符串排序：O(slogs)，将数组中的每一个字符串按照字母序排序：O(n*slog(s))，将整个字符串数组按照字典序排序:O(s*nlog(n))\n\nO(n*slog(s))+O(s*nlog(n))=O(n*s*logs+s*n*logn)=O(n*s*(logs+logn))\n\n很多时候算法复杂度是用例相关的。大多是情况还是关注平均情况。\n\n![image-20200117180908231](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117180908231.png)\n\n## 对数据规模有一个概念\n\n![image-20200117185209920](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117185209920.png)\n\n计算从10到10^9所用时间，运算结果：\n\n![image-20200117185320275](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117185320275.png)\n\n对数据规模有个概念：如果想在1s之内解决问题，用O(n^2)的算法可以处理大约10^4级别的数据；O(n)大约10^8级别的数据；O(nlogn)大约10^7级别的数据。对于多大规模的数据，我应该采用哪种时间复杂度来解决。\n\n空间复杂度：多开一个辅助的数组：O(n);多开一个辅助的二维数组：O(n^2)；多开一个常数：O(1)。\n\n递归调用是有空间代价的\n\n![image-20200117190253899](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117190253899.png)\n\n开了两个空间。\n\n![image-20200117190314500](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117190314500.png)\n\n递归调用，所以空间复杂度是O(n)。递归深度是n，系统栈中就要装n个状态。\n\n在递归调用中，递归深度是多少，整个递归过程就占用多少空间复杂度。\n\n## 常见的复杂度分析\n\n### O(1)\n\n`void swapTwoInts( int &a, int &b){`\n\n​\t` int temp = a;` \n\n`\t\ta=b;`\t\n\n`\tb=temp;`\n\n`}`\n\n### O(n)\n\n`void reverse( string &s ){`\n\n` int n = s.size();` \n\n`for (int i = 0; i< n/2; i++)`\n\n`swap(s[i],s[n-1-i]);`\n\n`}`\n\n进行了1/2*n次swap操作\n\n### O(n^2)\n\n`void selectionSort( int arr[], int n){`\n\n`\tfor(int i = 0;i < n; i++){`\t\n\n`\t\tint minIndex =i;`\t\t\n\n`for(int j = i+1;j<n;j++)`\n\n`  if(arr[j]<arr[minIndex])`  \n\n` minIndex = j;` \n\n`\tswap(arr[i],arr[minIndex]);`\t\n\n`}`\n\n`}`\n\nj执行了(n-1)+(n-2)+(n-3)+...+0=(0+n-1)*n/2=(1/2)n*(n-1)=1/2*n^2-1/2*n=O(n^2)。双重循环，每重循环都和n有关。\n\n![image-20200117191739177](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117191739177.png)\n\n对于第二重循环,j的执行次数是固定的\n\n### O(logn)\n\n`int binarySearch(int arr[],int n,int target){`\n\n`\tint l=0,r=n-1;`\t\n\n`\twhile (l<=r){`\t\n\n` int mid = l+(r-l)/2;` \n\n`\tif(arr[mid]==target) return mid;`\t\n\n`\tif(arr[mid]>target) r=mid-1;`\t\n\n`\telse l = mid +1;`\t\n\n`}`\n\n`return -1;`\n\n`}`\n\n二分查找法：每次查找要是没查找到就扔掉一半元素。在n个元素中找，在n/2个元素中找，在n/4个元素中找...在1个元素中找。n经过几次“除以2”操作后，等于1？log2n=O(logn)\n\n整形转成字符串：（只考虑num为正数）`string intToString(int num){`\n\n`string s =\"\";`\n\n`while(num){`\n\n`s+='0'+num%10;`\n\n`num /= 10;`\n\n`}`\n\n`reverse(s);`\n\n`return s;`\n\n`}`\n\nn经过几次“除以10”操作后，等于0？log10n=O(logn)\n\n![image-20200117193130571](C:\\Users\\zhangdi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200117193130571.png)\n\n我们说一个算法是对数复杂度的，通常忽略这个对数的底\n\n`void hello(int n){`\n\n`\tfor(int sz=1;sz<n;sz+=sz)`\t`这里sz+=sz是指每次乘以二，这重循环的复杂度是对数级别的`\n\n`\tfor (int i=1;i<n;i++)`\t\n\n`\tcout<<\"Hello,Algorithm!\"<<endl;`\t\n\n`}`\n\n虽然是双重循环，总共的复杂度为O(nlogn)。要注意循环的起始点和终止点，每次循环增量的变化。\n\n`bool isPrime(int n){`\n\n`\tfor(int x=2;x*x<=n;x++)`\t`O(sqrt(n))`\n\n​\t`if(n%x==0)` \n\n`return false;`\n\n`return true;`\n\n`}`\n\n判断一个数是不是素数？\n\n## 复杂度实验\n\n我们自以为写出了一个O(nlogn)的算法，但实际是O(n^2)的算法？\n\n实验，观察趋势。每次将数据规模提高两倍，观察\n\n`\\#include <iostream>`\n\n`#include(cassert)`\n\n`using namespace std;`\n\n`namespace MyAlgorithmTester{`\n\n`// O(logn)二分法*`\n\n`int binarySearch(int *arr*[],int *n*,int *target*){`\n\n  `int l=0,r=n-1;`\n\n`  while (l<=r){  `\n\n ` int mid = l+(r-l)/2;`\n\n`  if(arr[mid]==target) return mid;`\n\n ` if(arr[mid]>target) r=mid-1;  `\n\n ` else l = mid +1;  `\n\n`}`\n\n`return -1;`\n\n`}`\n\n\n\n`//O(n) 寻找最大值*`\n\n`int findMax(int *arr*[],int *n*){`\n\n ` assert(n>0);`\n\n ` int res = arr[0];`\n\n ` for(int i = 1; i < n; i++)`\n\n   ` if(arr[i]>res)`\n\n  `  res=arr[i];`\n\n`}`\n\n\n\n`//O(nlogn) 自顶向上的归并排序*`\n\n`void _merge(int *arr*[],int *l*,int *mid*,int *r*,int *aux*[]){`\n\n`  int i = l,j = mid+1;`\n\n  `for(int k=l;k<=r;k++){`\n\n  `  if(i>mid)`\n\n   ` {arr[k] = aux[j]; j++;}`\n\n​    `else if (j>r)`\n\n   ` {arr[k] = aux[i]; i++;}`\n\n   ` else if(aux[i]<aux[j])`\n\n  `  {arr[k] = aux[i]; i++;}`\n\n  `  else`\n\n  `  {arr[k] = aux[j]; j++}`\n\n  `}`\n\n`}`\n\n\n\n`//O(n^2) 选择排序算法*`\n\n`void selectionSort(int *arr*[],int *n*){`\n\n ` for (int i = 0;i < n; i++){`\n\n   ` int minIndex = i;`\n\n   ` for(int j = i + 1; j < n; j++)`\n\n​     ` if(arr[j]<arr[minIndex])`\n\n​      `  minIndex = j;`\n\n   ` swap(arr[i],arr[minIndex]);`\n\n ` }`\n\n`  return;`\n\n`}`\n\n`}`\n\nn乘以2以后，时间性能log2n/logn=(log2+logn)/logn=1+log2/logn。如果有个算法复杂度是logn级别，当数据扩大为2倍，效率会提高一点几倍。\n\n将顺序查找转换为二分查找，当数据规模很大时会节省很多时间\n"},{"title":"CS224n课程记录","url":"/2020/01/15/CS224n课程记录/","content":"# CS224N课程笔记-第一周\n\n寒假开始了，作为我的第一篇正式博客，我当然要用轻便快捷的[markdown语法](https://www.runoob.com/markdown/md-tutorial.html)来写了。作为一个身兼大创与考研重压的菜虚鸭，寒假的学习一定要搞起来。冲冲冲！\n\n## 课程介绍\n\n### Standford University CS224n《深度学习与NLP》课程\n\n自然语言是人类智慧的结晶，自然语言处理是人工智能中最为困难的问题之一，而对自然语言处理的研究也是充满魅力和挑战的。 通过经典的斯坦福cs224n教程，让我们一起和自然语言处理共舞！\n\n#### 第一周内容：\n\n观看自然语言处理课学习绪论，了解深度学习的概括和应用案例以及训练营后续的一些学习安排。\n\n##### 绪论\n\n[视频地址](https://m.weike.fm/lecture/10194068)\n\n###### 机器学习三板斧：好比把大象放入冰箱 \n\nStep1:define a set of function\n\nStep2:goodness of function \n\nStep3:pick the best function\n\n###### 深度学习=用多层次神经网络来找到函数 \n\n深度学习三板斧：\n\nStep1:Neural Network\n\nStep2:goodness of function\n\nStep3:pick the best function\n\n###### 深度学习VS机器学习\n\n深度学习对比机器学习能够实现端到端的模型，中间减少人为的参与\n\nNLP领域：（1）情绪分析（2）问答系统（3）文本处理\n\nAI大咖：[Yann LeCun](https://blog.csdn.net/hacker_long/article/details/89609367) \n\n##### lecture01 \n\n[视频地址](https://www.bilibili.com/video/av41393758/?spm_id_from=333.788.videocard.0)\n\n\n\n\n"},{"title":"Hello World","url":"/2020/01/13/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]